<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ§© íƒ€ì¼ ë§¤ì¹­ í¼ì¦ (AI ëŒ€ì „)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Jua', sans-serif;
            background-color: #f4f1de;
            color: #3d405b;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
        }
        .game-container {
            position: relative;
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }
        #game-board {
            display: grid;
            grid-template-columns: repeat(15, 45px);
            grid-template-rows: repeat(15, 45px);
            gap: 4px;
            background-color: #e07a5f;
            padding: 10px;
            border-radius: 10px;
            border: 5px solid #81b29a;
        }
        .board-cell {
            width: 45px;
            height: 45px;
            background-color: #f2cc8f;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s ease;
        }
        .board-cell:hover {
            background-color: #d8b780;
        }
        .board-cell.ai-move-highlight {
            box-shadow: 0 0 15px 5px #ffeb3b;
            border-radius: 8px;
            transform: scale(1.1);
        }
        .tile {
            width: 42px;
            height: 42px;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 28px;
            cursor: pointer;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            border: 2px solid transparent;
        }
        .sidebar {
            width: 250px;
            background-color: #81b29a;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        .hand-area {
            margin-top: 15px;
            background-color: #f4f1de;
            padding: 10px;
            border-radius: 5px;
            min-height: 150px;
        }
        .hand-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        .tile.selected {
            border-color: #e07a5f;
            transform: scale(1.1);
        }
        .tile.ai-tile-hidden {
            background-color: #3d405b !important;
            color: #3d405b !important;
        }
        #score-area {
            margin-top: 20px;
            background-color: #f4f1de;
            padding: 10px;
            border-radius: 5px;
        }
        #message {
            margin-top: 15px;
            font-size: 1.2em;
            color: #e07a5f;
            min-height: 40px;
            font-weight: bold;
        }
        .btn {
            font-family: 'Jua', sans-serif;
            font-size: 1.1em;
            padding: 10px 15px;
            margin-top: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background-color: #3d405b;
            color: white;
        }
        .btn:disabled {
            background-color: #999;
            cursor: not-allowed;
        }
        .score-popup {
            position: absolute;
            font-size: 2.5em;
            font-weight: bold;
            color: #e07a5f;
            text-shadow: 2px 2px 3px white;
            z-index: 20;
            pointer-events: none;
            opacity: 0;
            transition: all 1s ease-out;
        }
        .modal {
            display: none; 
            position: fixed; 
            z-index: 10; 
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto; 
            background-color: rgba(0,0,0,0.6);
        }
        .modal-content {
            text-align: center;
            background-color: #f4f1de;
            margin: 15% auto;
            padding: 30px;
            border: 5px solid #81b29a;
            border-radius: 10px;
            width: 80%;
            max-width: 500px;
            position: relative;
        }
        .close-btn {
            color: #aaa;
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close-btn:hover {
            color: #3d405b;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div id="game-board"></div>
        <div class="sidebar">
            <div id="score-area">
                <h3>í”Œë ˆì´ì–´: <span id="player-score">0</span></h3>
                <h3>AI: <span id="ai-score">0</span></h3>
            </div>
            <h2>ë‚´ íƒ€ì¼</h2><div id="player-hand-area" class="hand-area"><div class="hand-grid"></div></div>
            <h2>AI íƒ€ì¼</h2><div id="ai-hand-area" class="hand-area"><div class="hand-grid"></div></div>
            <p id="message">ê²Œì„ ì‹œì‘! íƒ€ì¼ì„ ì„ íƒí•˜ì„¸ìš”.</p>
            <button id="rules-btn" class="btn">ê·œì¹™ ë³´ê¸°</button>
            <button id="pass-turn-btn" class="btn">í„´ ë„˜ê¸°ê¸°</button>
            <button id="show-ai-move-btn" class="btn">AI ìœ„ì¹˜ ë³´ê¸°</button>
        </div>
    </div>

    <div id="rules-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn">&times;</span>
            <h2>ğŸ§© íƒ€ì¼ ë§¤ì¹­ í¼ì¦ ê·œì¹™</h2>
            <h4>ëª©í‘œ</h4><p>íƒ€ì¼ ì£¼ë¨¸ë‹ˆê°€ ë‹¤ ë–¨ì–´ì§ˆ ë•Œê¹Œì§€ ê°€ì¥ ë†’ì€ ì ìˆ˜ë¥¼ ì–»ëŠ” ê²ƒì´ ëª©í‘œì…ë‹ˆë‹¤.</p>
            <h4>íƒ€ì¼ ë†“ê¸° ê·œì¹™</h4><p><b>1. ì²« íƒ€ì¼:</b> ë³´ë“œê°€ ë¹„ì–´ìˆì„ ë•ŒëŠ” ì›í•˜ëŠ” íƒ€ì¼ì„ ì•„ë¬´ ê³³ì—ë‚˜ ë†“ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p><p><b>2. ë‹¤ìŒ íƒ€ì¼:</b> ê¸°ì¡´ì— ë†“ì¸ íƒ€ì¼ì˜ ìƒí•˜ì¢Œìš° ì¤‘ í•œ ê³³ ì´ìƒì— ë°˜ë“œì‹œ ë‹¿ë„ë¡ ë†“ì•„ì•¼ í•©ë‹ˆë‹¤.</p>
            <h4>ë¼ì¸ ê·œì¹™ (ê°€ì¥ ì¤‘ìš”!)</h4><p>í•œ ì¤„(ê°€ë¡œ ë˜ëŠ” ì„¸ë¡œ)ì€ ë°˜ë“œì‹œ ì•„ë˜ ë‘ ì¡°ê±´ ì¤‘ <b>í•˜ë‚˜ë§Œ</b> ë§Œì¡±í•´ì•¼ í•©ë‹ˆë‹¤.<br>- <b>ìƒ‰ê¹” í†µì¼:</b> ë¼ì¸ì˜ ëª¨ë“  íƒ€ì¼ì´ ê°™ì€ ìƒ‰ê¹” (ëª¨ì–‘ì€ ëª¨ë‘ ë‹¬ë¼ì•¼ í•¨)<br>- <b>ëª¨ì–‘ í†µì¼:</b> ë¼ì¸ì˜ ëª¨ë“  íƒ€ì¼ì´ ê°™ì€ ëª¨ì–‘ (ìƒ‰ê¹”ì€ ëª¨ë‘ ë‹¬ë¼ì•¼ í•¨)</p><p>â€» í•œ ì¤„ì— ìƒ‰ê¹”ê³¼ ëª¨ì–‘ì´ ëª¨ë‘ ë˜‘ê°™ì€ íƒ€ì¼ì€ 2ê°œ ì´ìƒ ìˆì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>
            <h4>ì ìˆ˜ ê³„ì‚°</h4><p>ë‚´ê°€ ë†“ì€ íƒ€ì¼ì´ í¬í•¨ëœ ë¼ì¸ì˜ íƒ€ì¼ ê°œìˆ˜ê°€ ì ìˆ˜ê°€ ë©ë‹ˆë‹¤. (4ì¹¸ì§œë¦¬ ì¤„ì„ ë§Œë“¤ë©´ 4ì )<br>êµì°¨ì ì— íƒ€ì¼ì„ ë†“ì•„ ê°€ë¡œì¤„ê³¼ ì„¸ë¡œì¤„ì„ ë™ì‹œì— ë§Œë“¤ë©´, ë‘ ì¤„ì˜ ì ìˆ˜ë¥¼ ëª¨ë‘ í•©ì‚°í•©ë‹ˆë‹¤.</p>
        </div>
    </div>

    <div id="game-over-modal" class="modal">
        <div class="modal-content">
            <h2 id="winner-title">ê²Œì„ ì¢…ë£Œ!</h2>
            <p id="winner-message" style="font-size: 1.5em; margin: 20px 0;"></p>
            <button id="play-again-btn" class="btn">ë‹¤ì‹œí•˜ê¸°</button>
        </div>
    </div>

    <script>
        const boardSize = 15;
        const handSize = 6;
        const colors = ['#E76F51', '#F4A261', '#E9C46A', '#2A9D8F', '#264653', '#8E6E53'];
        const shapes = ['â—', 'â– ', 'â—†', 'â–²', 'â˜…', 'âœš'];
        
        const gameContainer = document.querySelector('.game-container');
        const gameBoardEl = document.getElementById('game-board');
        const playerScoreEl = document.getElementById('player-score');
        const aiScoreEl = document.getElementById('ai-score');
        const playerHandGrid = document.querySelector('#player-hand-area .hand-grid');
        const aiHandGrid = document.querySelector('#ai-hand-area .hand-grid');
        const messageEl = document.getElementById('message');
        const passTurnBtn = document.getElementById('pass-turn-btn');
        const rulesModal = document.getElementById('rules-modal');
        const rulesBtn = document.getElementById('rules-btn');
        const closeBtn = document.querySelector('.close-btn');
        const showAiMoveBtn = document.getElementById('show-ai-move-btn');
        const gameOverModal = document.getElementById('game-over-modal');
        const winnerMessage = document.getElementById('winner-message');
        const winnerTitle = document.getElementById('winner-title');
        const playAgainBtn = document.getElementById('play-again-btn');

        let boardState, tileBag, playerHand, aiHand, playerScore, aiScore, selectedTile, currentPlayer, lastAiMove, consecutivePasses;

        function createTileElement(tile, isHidden = false) {
            if (!tile) return null;
            const tileDiv = document.createElement('div');
            tileDiv.className = 'tile';
            if (isHidden) {
                tileDiv.classList.add('ai-tile-hidden');
            } else {
                tileDiv.style.backgroundColor = tile.color;
                tileDiv.style.color = 'white';
                tileDiv.innerHTML = tile.shape;
            }
            return tileDiv;
        }
        
        function initializeGame() {
            boardState = Array(boardSize).fill(null).map(() => Array(boardSize).fill(null));
            tileBag = [];
            playerHand = [];
            aiHand = [];
            playerScore = 0;
            aiScore = 0;
            selectedTile = null;
            currentPlayer = 'player';
            lastAiMove = null;
            consecutivePasses = 0;

            for (let i = 0; i < 3; i++) {
                for (const color of colors) {
                    for (const shape of shapes) {
                        tileBag.push({ color, shape });
                    }
                }
            }
            shuffle(tileBag);
            
            for (let i = 0; i < handSize; i++) {
                drawTile('player');
                drawTile('ai');
            }

            gameBoardEl.innerHTML = '';
            for (let r = 0; r < boardSize; r++) {
                for (let c = 0; c < boardSize; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'board-cell';
                    cell.addEventListener('click', () => onCellClick(r, c));
                    gameBoardEl.appendChild(cell);
                }
            }
            
            gameOverModal.style.display = 'none';
            gameBoardEl.style.pointerEvents = 'auto';
            passTurnBtn.disabled = false;
            showAiMoveBtn.disabled = false;
            messageEl.textContent = "ê²Œì„ ì‹œì‘! íƒ€ì¼ì„ ì„ íƒí•˜ì„¸ìš”.";
            updateUI();
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function drawTile(player) {
            if (tileBag.length > 0) {
                const hand = (player === 'player') ? playerHand : aiHand;
                if (hand.length < handSize) {
                    hand.push(tileBag.pop());
                }
            }
        }
        
        function updateUI() {
            playerHandGrid.innerHTML = '';
            playerHand.forEach((tile, index) => {
                const tileEl = createTileElement(tile);
                if (selectedTile && selectedTile.index === index) tileEl.classList.add('selected');
                tileEl.addEventListener('click', () => onHandTileClick(tile, index));
                playerHandGrid.appendChild(tileEl);
            });
            aiHandGrid.innerHTML = '';
            aiHand.forEach(tile => aiHandGrid.appendChild(createTileElement(tile, true)));
            for (let r = 0; r < boardSize; r++) {
                for (let c = 0; c < boardSize; c++) {
                    const cell = gameBoardEl.children[r * boardSize + c];
                    cell.innerHTML = '';
                    if (boardState[r][c]) cell.appendChild(createTileElement(boardState[r][c]));
                }
            }
            playerScoreEl.textContent = playerScore;
            aiScoreEl.textContent = aiScore;
        }

        function switchTurn() {
            if (consecutivePasses >= 4 || (tileBag.length === 0 && playerHand.length === 0 && aiHand.length === 0)) {
                endGame();
                return;
            }
            currentPlayer = (currentPlayer === 'player') ? 'ai' : 'player';
            if (currentPlayer === 'ai') {
                messageEl.textContent = "AIê°€ ìƒê° ì¤‘ì…ë‹ˆë‹¤...";
                passTurnBtn.disabled = true;
                showAiMoveBtn.disabled = true;
                setTimeout(aiTurn, 1000);
            } else {
                messageEl.textContent = "ë‚´ ì°¨ë¡€! íƒ€ì¼ì„ ì„ íƒí•˜ì„¸ìš”.";
                passTurnBtn.disabled = false;
                showAiMoveBtn.disabled = false;
            }
        }
        
        function endGame() {
            let title = "", message = "";
            if (playerScore > aiScore) {
                title = "ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤! ğŸ‰";
                message = `í”Œë ˆì´ì–´ ìŠ¹ë¦¬!<br>ìµœì¢… ì ìˆ˜ ${playerScore} : ${aiScore}`;
            } else if (aiScore > playerScore) {
                title = "ğŸ¤– AI ìŠ¹ë¦¬ ğŸ¤–";
                message = `AIê°€ ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤!<br>ìµœì¢… ì ìˆ˜ ${playerScore} : ${aiScore}`;
            } else {
                title = "ë¬´ìŠ¹ë¶€!";
                message = `ì¹˜ì—´í•œ ì ‘ì „ ëì— ë¬´ìŠ¹ë¶€ì…ë‹ˆë‹¤!<br>ìµœì¢… ì ìˆ˜ ${playerScore} : ${aiScore}`;
            }
            winnerTitle.innerHTML = title;
            winnerMessage.innerHTML = message;
            gameOverModal.style.display = 'block';
            passTurnBtn.disabled = true;
            showAiMoveBtn.disabled = true;
            gameBoardEl.style.pointerEvents = 'none';
        }

        function showScorePopup(points, cellElement) {
            const popup = document.createElement('div');
            popup.className = 'score-popup';
            popup.textContent = `+${points}`;
            gameContainer.appendChild(popup);
            const cellRect = cellElement.getBoundingClientRect();
            const containerRect = gameContainer.getBoundingClientRect();
            popup.style.left = `${cellRect.left - containerRect.left + cellRect.width / 2 - popup.offsetWidth / 2}px`;
            popup.style.top = `${cellRect.top - containerRect.top + cellRect.height / 2 - popup.offsetHeight / 2}px`;
            setTimeout(() => { popup.style.opacity = '1'; popup.style.transform = 'translateY(-50px)'; }, 10);
            setTimeout(() => { popup.remove(); }, 1000);
        }

        function onHandTileClick(tile, index) {
            if (currentPlayer !== 'player') return;
            selectedTile = { tile, index };
            messageEl.textContent = 'íƒ€ì¼ì„ ë†“ì„ ë³´ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”.';
            updateUI();
        }

        function onCellClick(row, col) {
            if (currentPlayer !== 'player' || !selectedTile) return;
            const { isValid, reason, points } = checkMoveValidity(selectedTile.tile, row, col);
            if (isValid) {
                consecutivePasses = 0;
                const movedCell = gameBoardEl.children[row * boardSize + col];
                boardState[row][col] = selectedTile.tile;
                playerScore += points;
                playerHand.splice(selectedTile.index, 1);
                drawTile('player');
                selectedTile = null;
                updateUI();
                showScorePopup(points, movedCell);
                if (playerHand.length === 0 && tileBag.length === 0) { endGame(); return; }
                switchTurn();
            } else {
                messageEl.textContent = reason;
            }
        }

        function aiTurn() {
            let bestMove = { score: 0, tile: null, index: -1, row: -1, col: -1 };
            for (let r = 0; r < boardSize; r++) { for (let c = 0; c < boardSize; c++) { if (!boardState[r][c]) { aiHand.forEach((tile, index) => { const { isValid, points } = checkMoveValidity(tile, r, c); if (isValid && points > bestMove.score) { bestMove = { score: points, tile, index, row: r, col: c }; } }); } } }

            if (bestMove.tile) {
                consecutivePasses = 0;
                lastAiMove = { row: bestMove.row, col: bestMove.col };
                const movedCell = gameBoardEl.children[bestMove.row * boardSize + bestMove.col];
                boardState[bestMove.row][bestMove.col] = bestMove.tile;
                aiScore += bestMove.score;
                aiHand.splice(bestMove.index, 1);
                drawTile('ai');
                messageEl.textContent = `AIê°€ +${bestMove.score}ì ì„ ì–»ì—ˆìŠµë‹ˆë‹¤!`;
                updateUI();
                showScorePopup(bestMove.score, movedCell);
                movedCell.classList.add('ai-move-highlight');
                setTimeout(() => { 
                    movedCell.classList.remove('ai-move-highlight');
                    if (aiHand.length === 0 && tileBag.length === 0) { endGame(); return; }
                    switchTurn(); 
                }, 1500);
            } else {
                consecutivePasses++;
                let passMessage = "AIê°€ ë†“ì„ ê³³ì´ ì—†ì–´ í„´ì„ ë„˜ê¹ë‹ˆë‹¤.";
                if (tileBag.length > 0) {
                    passMessage = "AIê°€ ë†“ì„ ê³³ì´ ì—†ì–´ íƒ€ì¼ì„ êµì²´í•©ë‹ˆë‹¤.";
                    aiHand.forEach(tile => tileBag.push(tile)); 
                    aiHand = []; 
                    shuffle(tileBag); 
                    for (let i = 0; i < handSize; i++) drawTile('ai');
                }
                messageEl.textContent = passMessage;
                updateUI();
                setTimeout(() => {
                    switchTurn();
                }, 1500);
            }
        }
        
        function checkMoveValidity(tile, row, col) {
            if (boardState[row][col]) return { isValid: false, reason: 'ì´ë¯¸ íƒ€ì¼ì´ ìˆëŠ” ê³³ì…ë‹ˆë‹¤.', points: 0 };
            const isBoardEmpty = boardState.every(r => r.every(c => c === null));
            if (isBoardEmpty) return { isValid: true, points: 1 };
            if (Object.keys(getNeighbors(row, col)).length === 0) return { isValid: false, reason: 'ê¸°ì¡´ íƒ€ì¼ ì˜†ì— ë¶™ì—¬ì•¼ í•©ë‹ˆë‹¤.', points: 0 };
            const horizontalLine = getLine(row, col, 'horizontal');
            const verticalLine = getLine(row, col, 'vertical');
            horizontalLine.push(tile);
            verticalLine.push(tile);
            if (!isLineValid(horizontalLine)) return { isValid: false, reason: 'ê°€ë¡œì¤„ ê·œì¹™ ìœ„ë°˜!', points: 0 };
            if (!isLineValid(verticalLine)) return { isValid: false, reason: 'ì„¸ë¡œì¤„ ê·œì¹™ ìœ„ë°˜!', points: 0 };
            let points = 0;
            if (horizontalLine.length > 1) points += horizontalLine.length;
            if (verticalLine.length > 1) points += verticalLine.length;
            if (points === 0) points = 1;
            return { isValid: true, points };
        }
        
        function getNeighbors(row, col) { const neighbors = {}; if (row > 0 && boardState[row - 1][col]) neighbors.up = boardState[row - 1][col]; if (row < boardSize - 1 && boardState[row + 1][col]) neighbors.down = boardState[row + 1][col]; if (col > 0 && boardState[row][col - 1]) neighbors.left = boardState[row][col - 1]; if (col < boardSize - 1 && boardState[row][col + 1]) neighbors.right = boardState[row][col + 1]; return neighbors; }
        function getLine(row, col, direction) { const line = []; if (direction === 'horizontal') { let c = col - 1; while (c >= 0 && boardState[row][c]) { line.unshift(boardState[row][c]); c--; } c = col + 1; while (c < boardSize && boardState[row][c]) { line.push(boardState[row][c]); c++; } } else { let r = row - 1; while (r >= 0 && boardState[r][col]) { line.unshift(boardState[r][col]); r--; } r = row + 1; while (r < boardSize && boardState[r][col]) { line.push(boardState[r][col]); r++; } } return line; }
        function isLineValid(line) { if (line.length <= 1) return true; const stringified = line.map(t => `${t.color}-${t.shape}`); if (new Set(stringified).size !== stringified.length) return false; const allSameColor = line.every(tile => tile.color === line[0].color); const allSameShape = line.every(tile => tile.shape === line[0].shape); return allSameColor !== allSameShape; }
        
        passTurnBtn.addEventListener('click', () => {
             if (currentPlayer !== 'player') return;
             consecutivePasses++;
             messageEl.textContent = "í„´ì„ ë„˜ê¹ë‹ˆë‹¤.";
             if (tileBag.length > 0) {
                 playerHand.forEach(tile => tileBag.push(tile)); playerHand = []; shuffle(tileBag); for (let i = 0; i < handSize; i++) drawTile('player');
             }
             updateUI();
             switchTurn();
        });
        
        playAgainBtn.addEventListener('click', () => {
            initializeGame();
        });

        showAiMoveBtn.addEventListener('click', () => { if(lastAiMove) { const cell = gameBoardEl.children[lastAiMove.row * boardSize + lastAiMove.col]; cell.classList.add('ai-move-highlight'); setTimeout(() => { cell.classList.remove('ai-move-highlight'); }, 1500); } });
        rulesBtn.addEventListener('click', () => { rulesModal.style.display = 'block'; });
        closeBtn.addEventListener('click', () => { rulesModal.style.display = 'none'; });
        window.addEventListener('click', (event) => { if (event.target == rulesModal) { rulesModal.style.display = 'none'; } });

        initializeGame();
    </script>
</body>
</html>
